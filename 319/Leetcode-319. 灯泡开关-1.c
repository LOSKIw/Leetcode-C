int bulbSwitch(int n) {
	int i;
	for (i = 1; i*i <= n; i++);
	return i - 1;
}
/*
2019/3/23
......
我已经不知道该说什么了，怪不得被分在脑筋急转弯的部分...

首先思考：灯泡i会被按几次？这其实相当于求i有几个因子 比如灯泡8,一共会被按4次，分别是第一轮 第二轮 第四轮 第八轮
一开始灯都是灭的，所以如果i有k个因子，且k为奇数，那么最终灯就亮，如果为偶数，灯就灭。 那么问题就转化成了，求1..n每个数分别有几个因子。 最直观的做法就是，枚举i，然后计算i的因子数。怎么计算呢？ 最直观的做法就是枚举j=0..i，count+= i%j==0 ? 1:0; 这里有个优化的点，假如xy=z，显然z%y==0且z%x==0。 也就是说你只要需要枚举j从到1..根号i，count += i%j==0? 2:0;
在写完上面的式子之后你突然可以发现，**在根号i的左边每发现一个j使得i%j==0，那么根号i的右边一定存在一个k同样满足i%k==0，一次枚举会把count+2。**而我们关心的其实是最终count为奇数还是偶数！！通过枚举，count最终的结果都是偶数，当且仅当 i可以被开根号时，count才会是奇数！
然后其实问题转换成了，求数字1..n中有几个数能开更开得尽（结果是整数）
想到这里，你就可以一个O(n)的枚举来完成了吗？ 其实还可以优化！
想想，在1..n中，假设n等于100，11 22 33 44 ... 1010的结果都小于等于100，换句话说，11 ... 根号n根号n 都<= n，所以求1..n里有几个开根号能开尽的数，其实就是求根号n向下取整等于几。
所以最终答案就是 (n as f64).sqrt().floor() as i32
还能优化不？ 当然还可以！
求n开根号怎么求，有大量的论文可以参考，它们收敛速度能比语言自带的sqrt还快！

简单来说，就是看因子数目，下面我有一个这么做的示范，但是想的还不够透。但凡有因子的（没有因子必定最后为开启状态），他的因子是两两成对的，因此到最后还是会关闭，但是有特例，那便是当他是平方数时，他的因子数为奇数，到最后也就会开启，因此，也就转变成为了找范围内的平方数数目了。
*/